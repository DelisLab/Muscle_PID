

%Simulate two EMG signals ['EMG_1','EMG_2'] that are generated by summing
%sinusoids from a frequency range typically found in EMGs, encode them both with
%a binary task parameter and then inject noise with a specified
%correlational structure


N=100; %The number of simulated samples
%noise_correlation=[-0.9:0.1:0.9];
frequencies=[20:150]; %Select a realistic range of frequencies to effectively simulate EMGs
trials=10;% The number of trial each with N samples

Rs=[];Ss=[];UYs=[];UZs=[];
for corr=-0.9:0.1:0.9 %iterative over a range of noise correlation values
    r=[];s=[];uy=[];uz=[];
    noise_correlation=corr;
    for K=1:100 %simulate K fold simulations of the EMG signals
        [EMG_1, EMG_2, task_param] = simulate_emg_data(N, noise_correlation, frequencies,trials);
        [R,S,UY,UZ] =Gaussian_PID(EMG_1,EMG_2,task_param);%Apply PID to the simulated signals with respect to the simulated task parameter
        
        %Normalise the derived quantities to determine their relative
        %contributions to the total shared information (i.e. the joint mutual information (JMI))
        JMI=sum([R,S,UY,UZ]);
        r=[r;R/JMI];
        s=[s;S/JMI];
        uy=[uy;UY/JMI];
        uz=[uz;UZ/JMI];
    end
    %Extract the average of each quantity to summarise the output at each
    %correlation level
    Rs=[Rs;[mean(r)]];
    Ss=[Ss;[mean(s)]];
    UYs=[UYs;[mean(uy)]];
    UZs=[UZs;[mean(uz)]];
end


%Plot figure with averages of each step
figure;
bar(Ss(:,1),'FaceColor', [1, 0.5, 0]);
hold on;
box off;
xticks(1:19);
xticklabels(-0.9:0.1:0.9)
hold on
box off;
bar(UZs(:,1),'c');
bar(UYs(:,1),'m');
bar(Rs(:,1),'FaceColor', [1, 0.4, 0.6]);

ylim([0,max(max([Rs,Ss,UYs,UZs]))+0.1]);
ylabel('Normalised Bits');
xlabel('\Leftarrow Noise Correlation \Rightarrow')

